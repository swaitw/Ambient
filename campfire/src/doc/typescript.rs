use std::{fs::File, io::Write, path::Path};

use super::parser;

pub trait GenerateTypescriptDefinition {
    fn generate(&self, file: &mut File, indent: usize) -> anyhow::Result<()>;
    fn generate_unscoped(&self, file: &mut File, indent: usize) -> anyhow::Result<()>;
}

pub fn generate(ty: &parser::Type, output_path: &Path) -> anyhow::Result<()> {
    let mut file = std::fs::File::create(output_path)?;
    writeln!(
        file,
        "// This file is generated by `campfire`. Please do not manually edit it."
    )?;

    for (alias, ts_type) in [
        ("u32", "number"),
        ("f32", "number"),
        ("Vec2", "[number, number]"),
        ("Vec3", "[number, number, number]"),
        ("Vec4", "[number, number, number, number]"),
        ("Entity", "{[component_id: string]: any}"),
        ("AssetUrl", "string"),
    ] {
        writeln!(file, "export type {alias} = {ts_type};")?;
    }

    writeln!(file)?;

    write!(file, "export type {} = ", ty)?;
    ty.generate(&mut file, 1)
}

impl GenerateTypescriptDefinition for parser::Type {
    fn generate(&self, file: &mut File, indent: usize) -> anyhow::Result<()> {
        match self {
            parser::Type::Struct(s) => s.generate(file, indent)?,
            parser::Type::Enum(s) => s.generate(file, indent)?,
            parser::Type::List(s) => {
                let is_enum = matches!(**s, parser::Type::Enum(_));
                if is_enum {
                    write!(file, "(")?;
                }
                s.generate(file, indent)?;
                if is_enum {
                    write!(file, ")")?;
                }
                write!(file, "[]")?
            }
            parser::Type::Option(s) => {
                s.generate(file, indent)?;
                write!(file, " | null")?
            }
            _ => self.generate_unscoped(file, indent)?,
        }
        Ok(())
    }
    fn generate_unscoped(&self, file: &mut File, indent: usize) -> anyhow::Result<()> {
        match self {
            parser::Type::Struct(s) => s.generate_unscoped(file, indent)?,
            parser::Type::Enum(s) => s.generate_unscoped(file, indent)?,
            parser::Type::List(s) => {
                let is_enum = matches!(**s, parser::Type::Enum(_));
                if is_enum {
                    write!(file, "(")?;
                }
                s.generate_unscoped(file, indent)?;
                if is_enum {
                    write!(file, ")")?;
                }
                write!(file, "[]")?
            }
            parser::Type::Option(s) => {
                s.generate_unscoped(file, indent)?;
                write!(file, " | null")?
            }
            parser::Type::Primitive(s) => write!(
                file,
                "{}",
                match s.as_str() {
                    "bool" => "boolean",
                    other => other,
                }
            )?,
            parser::Type::StringLiteral(s) => write!(file, "{s:?}")?,
            parser::Type::String => write!(file, "string")?,
            parser::Type::AssetUrl => write!(file, "AssetUrl")?,
            parser::Type::Vec2 => write!(file, "Vec2")?,
            parser::Type::Vec3 => write!(file, "Vec3")?,
            parser::Type::Vec4 => write!(file, "Vec4")?,
            parser::Type::Entity => write!(file, "Entity")?,
        }
        Ok(())
    }
}

impl GenerateTypescriptDefinition for parser::Struct {
    fn generate(&self, file: &mut File, indent: usize) -> anyhow::Result<()> {
        writeln!(file, "{{")?;
        self.generate_unscoped(file, indent)?;
        write!(file, "{}}}", make_indent(indent - 1))?;
        Ok(())
    }
    fn generate_unscoped(&self, file: &mut File, indent: usize) -> anyhow::Result<()> {
        for field in &self.fields {
            field.generate(file, indent)?;
        }
        Ok(())
    }
}

impl GenerateTypescriptDefinition for parser::Enum {
    fn generate(&self, file: &mut File, indent: usize) -> anyhow::Result<()> {
        self.generate_unscoped(file, indent)
    }
    fn generate_unscoped(&self, file: &mut File, indent: usize) -> anyhow::Result<()> {
        if let Some(tag) = self.tag.as_ref() {
            let mut first = true;
            for (variant_name, docs, ty) in &self.variants {
                if !first {
                    write!(file, " | ")?;
                }
                writeln!(file, "{{")?;
                parser::Field {
                    docs: docs.to_owned(),
                    name: tag.to_owned(),
                    ty: parser::Type::StringLiteral(variant_name.to_owned()),
                    default: false,
                }
                .generate(file, indent)?;
                if let Some(ty) = ty {
                    ty.generate_unscoped(file, indent)?;
                }
                write!(file, "{}}}", make_indent(indent - 1))?;

                first = false;
            }
        } else {
            let mut first = true;
            let indent_str = make_indent(indent);
            for (variant_name, docs, ty) in &self.variants {
                if !first {
                    write!(file, " | ")?;
                }
                writeln!(file)?;
                if let Some(ty) = ty {
                    print_doc_comment(file, &indent_str, docs)?;
                    write!(file, "{indent_str}{{{variant_name:?}: ")?;
                    ty.generate(file, indent)?;
                    write!(file, "}}")?;
                } else {
                    print_doc_comment(file, &indent_str, docs)?;
                    write!(file, "{indent_str}{variant_name:?}")?;
                }

                first = false;
            }
        }
        Ok(())
    }
}

impl GenerateTypescriptDefinition for parser::Field {
    fn generate(&self, file: &mut File, indent: usize) -> anyhow::Result<()> {
        self.generate_unscoped(file, indent)
    }

    fn generate_unscoped(&self, file: &mut File, indent: usize) -> anyhow::Result<()> {
        let indent_str = make_indent(indent);
        print_doc_comment(file, &indent_str, &self.docs)?;

        let mut default = self.default;
        let mut ty = &self.ty;
        if let parser::Type::Option(inner_ty) = ty {
            ty = inner_ty.as_ref();
            default = true;
        }

        write!(
            file,
            "{indent_str}{}{}: ",
            self.name,
            if default { "?" } else { "" }
        )?;
        ty.generate(file, indent + 1)?;
        writeln!(file, ",")?;

        Ok(())
    }
}

fn print_doc_comment(file: &mut File, indent_str: &str, docs: &str) -> anyhow::Result<()> {
    if !docs.is_empty() {
        for line in docs.lines() {
            writeln!(file, "{indent_str}/// {line}")?;
        }
    }
    Ok(())
}

fn make_indent(indent: usize) -> String {
    "  ".repeat(indent)
}
